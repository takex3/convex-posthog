import type { Expand, FunctionReference } from "convex/server";
import type { GenericId } from "convex/values";
import type { RunMutationCtx } from "./types.js";

/**
 * PostHog component API shape
 *
 * Note: During component development, there's a bootstrapping issue:
 * - The build needs the component types
 * - But component types are generated by running `convex dev`
 * - Which requires the build to complete first
 *
 * Solution: Explicitly define the API shape here instead of relying on
 * generated types from `_generated/api.js`
 */
export type PostHogComponent = {
  lib: {
    trackEvent: FunctionReference<
      "action",
      "internal",
      {
        apiKey: string;
        host?: string;
        userId: string;
        event: string;
        properties?: Record<string, unknown>;
      },
      null
    >;
  };
};

export type PostHogOptions = {
  /**
   * PostHog API key. If not provided, will read from POSTHOG_API_KEY environment variable.
   */
  apiKey?: string;

  /**
   * PostHog host URL. Defaults to https://app.posthog.com
   */
  host?: string;
};

/**
 * PostHog analytics component for Convex
 *
 * Example usage:
 * ```ts
 * import { components } from "./_generated/api";
 * import { PostHog } from "@your-org/convex-posthog";
 *
 * const posthog = new PostHog(components.posthog, {
 *   apiKey: process.env.POSTHOG_API_KEY,
 *   host: process.env.POSTHOG_HOST,
 * });
 *
 * // In a mutation:
 * await posthog.trackUserEvent(ctx, {
 *   userId: "user_123",
 *   event: "user_created",
 *   properties: { email: "user@example.com" }
 * });
 * ```
 */
export class PostHog {
  private apiKey: string;
  private host: string;

  constructor(
    public component: PostHogComponent,
    options?: PostHogOptions
  ) {
    this.apiKey = options?.apiKey ?? process.env.POSTHOG_API_KEY ?? "";
    this.host = options?.host ?? process.env.POSTHOG_HOST ?? "https://app.posthog.com";
  }

  /**
   * Track user events from mutations - schedules as background job
   *
   * This method schedules the event tracking to run in the background using
   * ctx.scheduler.runAfter(0, ...), which means it won't block the current mutation
   * and analytics failures won't affect your app's core functionality.
   *
   * @param ctx - The mutation context
   * @param data - Event data including userId, event name, and optional properties
   *
   * @example
   * ```ts
   * await posthog.trackUserEvent(ctx, {
   *   userId: "user_123",
   *   event: "user_created",
   *   properties: { email: "user@example.com", plan: "pro" }
   * });
   * ```
   */
  async trackUserEvent(
    ctx: RunMutationCtx,
    data: {
      userId: string;
      event: string;
      properties?: Record<string, unknown>;
    }
  ): Promise<void> {
    if (!this.apiKey) {
      console.warn("PostHog API key not configured, skipping event tracking");
      return;
    }

    await ctx.scheduler.runAfter(0, this.component.lib.trackEvent, {
      apiKey: this.apiKey,
      host: this.host,
      userId: data.userId,
      event: data.event,
      properties: data.properties,
    });
  }
}

// Type helpers for component API usage
export type OpaqueIds<T> =
  T extends GenericId<infer _T>
    ? string
    : T extends (infer U)[]
      ? OpaqueIds<U>[]
      : T extends ArrayBuffer
        ? ArrayBuffer
        : T extends object
          ? { [K in keyof T]: OpaqueIds<T[K]> }
          : T;

export type UseApi<API> = Expand<{
  [mod in keyof API]: API[mod] extends FunctionReference<
    infer FType,
    "public",
    infer FArgs,
    infer FReturnType,
    infer FComponentPath
  >
    ? FunctionReference<
        FType,
        "internal",
        OpaqueIds<FArgs>,
        OpaqueIds<FReturnType>,
        FComponentPath
      >
    : UseApi<API[mod]>;
}>;
